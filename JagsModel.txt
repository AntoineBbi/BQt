model
{
    c1 <- (1 - 2 * tau)/(tau * (1 - tau))
    c2 <- 2/(tau * (1 - tau))
    for (i in 1:I) {
        for (j in offset[i]:(offset[i + 1] - 1)) {
            y[j] ~ dnorm(mu[j], prec[j])
            va1[j] ~ dexp(1/sigma)
            prec[j] <- 1/(sigma * c2 * va1[j])
            mu[j] <- inprod(beta[1:ncX], X[j, 1:ncX]) + b[i, 1] * U[j, 1] + c1 * va1[j]
        }
        for (r in 1:ncU) {
            b[i, r] ~ dnorm(0, prec.Sigma2[r])
        }
        etaBaseline[i] <- alpha[1] * Z[i, 1] + alpha[2] * Z[i, 2] + alpha[3] * Z[i, 3] + alpha[4] * Z[i, 4] + alpha[5] * Z[i, 5] + alpha.assoc[1] * b[i,  1]
        log_S1[i] <- -exp(etaBaseline[i]) * pow(Time[i], shape)
        log_h1[i] <- log(shape) + (shape - 1) * log(Time[i]) + etaBaseline[i]
        logL[i] <- event[i] * log_h1[i] + log_S1[i]
        mlogL[i] <- -logL[i] + C
        zeros[i] ~ dpois(mlogL[i])
    }
    for (rr in 1:ncU) {
        prec.Sigma2[rr] ~ dgamma(priorA.Sigma2, priorB.Sigma2)
    }
    beta[1:ncX] ~ dmnorm(priorMean.beta[], priorTau.beta[, ])
    sigma ~ dgamma(priorA.sigma, priorB.sigma)
    alpha[1:ncZ] ~ dmnorm(priorMean.alpha[], priorTau.alpha[, ])
    shape ~ dgamma(priorA.shape, priorB.shape)
    for (rr in 1:ncU) {
        alpha.assoc[rr] ~ dnorm(0, priorTau.alphaA)
    }
}
